% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TGL_kmeans.R
\name{TGL_kmeans}
\alias{TGL_kmeans}
\title{kmeans++ with return value similar to R kmeans}
\usage{
TGL_kmeans(df, k, metric = "euclid", max_iter = 40, min_delta = 0.0001,
  verbose = FALSE, keep_log = TRUE, id_column = TRUE,
  reorder_func = "hclust", seed = NULL, bootstrap = FALSE, ...)
}
\arguments{
\item{df}{data frame. Each row is a single observation and each column is a dimension.
the first column can contain id for each observation (if id_column is TRUE).}

\item{k}{number of clusters}

\item{metric}{distance metric for kmeans++ seeding. can be 'euclid', 'pearson' or 'spearman'}

\item{max_iter}{maximal number of iterations}

\item{min_delta}{minimal change in assignments (fraction out of all observations) to continue iterating}

\item{verbose}{display algorithm messages}

\item{keep_log}{keep algorithm messages in 'log' field}

\item{id_column}{\code{df}'s first column contains the observation id}

\item{reorder_func}{function to reorder the clusters. operates on each center and orders by the result. e.g. \code{reorder_func = mean} would calculate the mean of each center and then would reorder the clusters accordingly. If \code{reorder_func = hclust} the centers would be ordered by hclust of the euclidian distance of the corelation matrix, i.e. \code{hclust(dist(cor(t(centers))))}
if NULL, no reordering would be done.}

\item{seed}{seed for the c++ random number generator}

\item{bootstrap}{bootstrap to estimate robustness of the clusters}

\item{...}{}

\item{...}{Arguments passed on to \code{bootstrap_kmeans}
\describe{
  \item{df}{data frame. Each row is a single observation and each column is a dimension.
the first column can contain id for each observation (if id_column is TRUE).}
  \item{k}{number of clusters}
  \item{N_boot}{number of bootstrapping iterations}
  \item{boot_ratio}{percent of observations to sample on each iteration}
  \item{parallel}{run parallely (using doMC backend)}
  \item{id_column}{\code{df}'s first column contains the observation id}
  \item{tidy}{return 'tidy' output}
}}
}
\value{
list with the following components:
\describe{
  \item{cluster:}{A vector of integers (from ‘1:k’) indicating the cluster to which each point is allocated.}
  \item{centers:}{A matrix of cluster centres.}
  \item{size:}{The number of points in each cluster.}
  \item{log:}{messages from the algorithm run (only if \code{id_column == TRUE}).}
  \item{bootstrap:}{number of times the members of the clusters were clustered together divided by the total times they were sampled together (only if bootstrap = TRUE).}
}
}
\description{
kmeans++ with return value similar to R kmeans
}
\examples{

library(dplyr)

# create 5 clusters normally distribution around 1:5
d <- purrr::map_df(1:5, ~
     as.data.frame(matrix(rnorm(100, mean=.x, sd = 0.3), ncol = 2))) \%>\%
         mutate(id = 1:n()) \%>\%
         select(id, everything())
head(d)

# cluster
km <- TGL_kmeans(d, k=5, 'euclid', verbose=TRUE)
names(km)
km$centers
head(km$cluster)
km$size

# bootstrapping
km <- TGL_kmeans(d, k=5, 'euclid', N_boot=100, bootstrap=TRUE)
km$bootstrap

}
\seealso{
\code{\link{TGL_kmeans_tidy}}
}
