% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TGL_kmeans.R
\name{TGL_kmeans_tidy}
\alias{TGL_kmeans_tidy}
\title{TGL kmeans with 'tidy' output}
\usage{
TGL_kmeans_tidy(df, k, metric = "euclid", max_iter = 40,
  min_delta = 0.0001, verbose = FALSE, keep_log = TRUE,
  id_column = TRUE, reorder_func = "hclust", seed = NULL)
}
\arguments{
\item{df}{data frame. Each row is a single observation and each column is a dimension.
the first column can contain id for each observation (if id_column is TRUE).}

\item{k}{nunmber of clusters}

\item{metric}{distance metric for kmeans++ seeding. can be 'euclid', 'pearson' or 'spearman'}

\item{max_iter}{maximal number of iterations}

\item{min_delta}{minimal change in assignments (fraction out of all observations) to continue iterating}

\item{verbose}{display algorithm messages}

\item{keep_log}{keep algorithm messages in 'log' field}

\item{id_column}{\code{df}'s first column contains the observation id}

\item{reorder_func}{function to reorder the clusters. operates on each center and orders by the result. e.g. \code{reorder_func = mean} would calculate the mean of each center and then would reorder the clusters accordingly. If \code{reorder_func = hclust} the centers would be ordered by hclust of the euclidian distance of the corelation matrix, i.e. \code{hclust(dist(cor(t(centers))))}
if NULL, no reordering would be done.}

\item{seed}{seed for the c++ random number generator}
}
\value{
list with the following components:
\describe{
  \item{cluster:}{tibble with `id` column with the observation id (`1:n` if no id column was supplied), and `clust` column with the observation assigned cluster.}
  \item{centers:}{tibble with `clust` column and the cluster centers.}
  \item{size:}{tibble with `clust` column and `n` column with the number of points in each cluster.}
  \item{log:}{messages from the algorithm run (only if \code{id_column = TRUE}).}
}
}
\description{
TGL kmeans with 'tidy' output
}
\examples{

library(dplyr)
# create 5 clusters normally distribution around 1:5
d <- purrr::map_df(1:5, ~ 
     as.data.frame(matrix(rnorm(100, mean=.x, sd = 0.3), ncol = 2))) \%>\% 
         mutate(id = 1:n()) \%>\% 
         select(id, everything())
head(d)

# cluster
km <- TGL_kmeans_tidy(d, k=5, 'euclid', verbose=TRUE)
km

   
}
\seealso{
\code{\link{TGL_kmeans}}
}
